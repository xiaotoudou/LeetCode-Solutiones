## 最长有效括号_32
> 题目：
> 给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。
>
> 示例1：
>
> ```txt
> 输入: "(()"
> 输出: 2
> 解释: 最长有效括号子串为 "()"
> ```
>
> 示例2
> ```txt
> 输入: ")()())"
> 输出: 4
> 解释: 最长有效括号子串为 "()()"
> ```
>
> 题目来源： [力扣 (LeetCode) ](https://leetcode-cn.com/problems/longest-valid-parentheses)
>
> Edited by xiaotudou on 2020/3/7

- - - -

### 贪心

“最长” ， 最优子结构问题，属于动态规划方向。
先考虑能不能用贪心，能不能用局部最优推出全局最优，换一种说法，是否可以划分成不重叠的子问题，进一步考虑：**如果存在一个右括号 “)”，左边没有可以与之配对的，那么这个括号为“无效括号“，在它之前的子串(包括该括号)不可能是之后有效子串的一部分。**

> 简单证明：假设一个右括号左侧没有能与它配对，且它属于一段有效子串的中间部分。如果它属于有效子串的一部分，那么必定有与它配对的左括号，与条件矛盾，原命题得证。

这个问题就转化成找到无效括号“)”，在它之后第一个字符作为起点，找最长子串的子问题，这个过程就和[LC53(最大子序列和)](https://leetcode-cn.com/problems/maximum-subarray/)是类似的，最长子序列和的起点条件是和小于0。

Java实现，时间复杂度$O(n)$，空间复杂度$O(n)$

```java
public int longestValidParentheses(String s) {
        int maxLen=0;
        Deque<Integer> stock = new ArrayDeque<>();
        // ”-1“ 作为起始点，方便通过下标做差求子串长度
        stock.addLast(-1); 
        for(int i=0;i<s.length();++i){
            // 左括号直接进栈，它是有可能在未来配对的
            if(s.charAt(i)=='('){
                stock.offerLast(i);
            }else{
                stock.pollLast();
                // 能够将”-1“弹出的只能是“无效右括号”
                if(stock.isEmpty()){
                    // 用”无效右括号“的下标作为新起点
                    stock.offerLast(i); 
                }
                else{
                    maxLen=Math.max(i-stock.peekLast(),maxLen);
                }
            }
        }
        return maxLen;
    }
```

### 动态规划

暴力法穷举所有子串$O(n^2)$，然后逐个判断子串是否有效$O(n)$，时间复杂度$O(n^3)$。想办法剪枝消灭冗余计算，从左往右遍历字符过程中，**只用考虑右括号加入时是否会影响左侧子串**，如果左侧子串是有效的，我只需要判断新加入的括号，左侧有效子串的最外层是否有能够与它配对的右括号既可。第二步，如果形成一个新的子串，观察能否与左侧最外层的其他子串连接在一起，组成更长的子串。因此需要一个数组记录左侧能够形成有效子串的情况，方便后面追加括号时，进行快速判断。

比较难的就是设计一个表保存信息：1. 快速查询左侧子串有效长度 2. 快速查询扩容后新有效子串是否能与左侧子串连接。采用一个数组保存以**对应下标括号作为结尾时，有效子串的长度**

每次增加一个右括号i，只需要判断该括号左侧是否是有效子串，如果是，直接判断 **i-validLen-1**是否是可以与之配对，valid为左侧的有效子串的长度。如果可以，当前有效子串长度增加2，如果不行，说明是一个“无效右括号”。使用一个数组来保存每个括号作为结尾时的最长有效子串，动态转移方程： 如果下标为$i - dp[ i-1 ] - 1$处的字符是左括号，$dp[ i ] =  dp[ i - dp[ i -1 ] -2] + dp[ i - 1 ] +2$。

Java实现，时间复杂度O(n)，空间复杂度O(n)：

```java
public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int maxLen = 0;
        for(int i=1;i<s.length();++i){
          // 只有右括号可能是有效子串的结尾 + 边界控制
            if(s.charAt(i) == ')' && i-dp[i-1]-1>=0){
                if(s.charAt(i-dp[i-1]-1) == '('){
                  // 可能当前配对的‘(’是第一个字符，在它左侧没有有效子串可以连接在一起
                    if(i-dp[i-1]-2>=0){
                        dp[i]=dp[i-dp[i-1]-2]+dp[i-1]+2;
                    }
                    else{
                        dp[i]=dp[i-1]+2;
                    }
                    maxLen=Math.max(dp[i],maxLen);
                }
            }
        }
        return maxLen;
    }
```



